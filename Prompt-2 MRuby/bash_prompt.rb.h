char *code() { return(
	"PWD = CPrompt.get_pwd\n"
	"hostname = CPrompt.get_hostname\n"
	"logname = CPrompt.get_logname\n"
	"current_time = CPrompt.get_current_time\n"
	"children = CPrompt.count_files\n"
	"TMPFILE = \"/tmp/bash_prompt_#{logname}.lock\"\n"
	"class String\n"
	"def hex_to_rgb(hex)\n"
	"return [\n"
	"255 & hex >> 16,\n"
	"255 & hex >> 8,\n"
	"255 & hex\n"
	"] if hex.is_a?(Integer)\n"
	"colour = hex && hex.dup.to_s || ''\n"
	"colour.strip!\n"
	"colour.downcase!\n"
	"colour[0] = ''.freeze if colour[0] == ?#.freeze\n"
	"oor = colour.scan(/[^a-f0-9]/)\n"
	"unless oor.empty?\n"
	"invalids = colour.chars.map { |x|\n"
	"oor.include?(x) ? \"\\e[1;31m#{x}\\e[0m\" : x\n"
	"}.join\n"
	"raise ArgumentError, \"\\e[0mHex Colour \\e[1m##{invalids} is Out of Range\\e[0m\"\n"
	"end\n"
	"clen = colour.length\n"
	"if clen == 3\n"
	"colour.chars.map { |x| x.<<(x).to_i(16) }\n"
	"elsif clen == 6\n"
	"colour.chars.each_slice(2).map { |x| x.join.to_i(16) }\n"
	"else\n"
	"sli = clen > 6 ? 'too long'.freeze : clen < 3 ? 'too short'.freeze : 'invalid'.freeze\n"
	"raise ArgumentError, \"Invalid Hex Colour ##{colour} (length #{sli})\"\n"
	"end\n"
	"end\n"
	"def gradient(*arg_colours,\n"
	"exclude_spaces: true,\n"
	"bg: false,\n"
	"bold: false,\n"
	"italic: false,\n"
	"underline: false,\n"
	"blink: false,\n"
	"strikethrough: false,\n"
	"double_underline: false,\n"
	"overline: false\n"
	")\n"
	"space, tab = ?\\s.freeze, ?\\t.freeze\n"
	"block_given = block_given?\n"
	"temp = ''\n"
	"flatten_colours = arg_colours.flatten\n"
	"style = nil\n"
	"if bold || italic || underline || blink || strikethrough || double_underline || overline\n"
	"style = \"\\e[\"\n"
	"style << '1;'.freeze if bold\n"
	"style << '3;'.freeze if italic\n"
	"style << '4;'.freeze if underline\n"
	"style << '5;'.freeze if blink\n"
	"style << '9;'.freeze if strikethrough\n"
	"style << '21;'.freeze if double_underline\n"
	"style << '53;'.freeze if overline\n"
	"style.chop!\n"
	"style << ?m.freeze\n"
	"end\n"
	"raise ArgumentError, \"Wrong numeber of colours (given #{flatten_colours.length}, expected minimum 2)\" if flatten_colours.length < 2\n"
	"raise ArgumentError, \"Given argument for colour is neither a String nor an Integer\" if flatten_colours.any? { |x| !(x.is_a?(String) || x.is_a?(Integer)) }\n"
	"all_rgbs = flatten_colours.map!(&method(:hex_to_rgb))\n"
	"yield style if block_given && style\n"
	"r, g, b = *all_rgbs[0]\n"
	"r2, g2, b2 = *all_rgbs[1]\n"
	"rotate = all_rgbs.length > 2\n"
	"init = bg ? 48 : 38\n"
	"lines do |c|\n"
	"temp << style if style\n"
	"_r, _g, _b = r, g, b\n"
	"chomped = !!c.chomp!(''.freeze)\n"
	"len = c.length\n"
	"n_variable = exclude_spaces ? c.delete(\"\\t\\s\".freeze).length : len\n"
	"n_variable -= 1\n"
	"n_variable = 1 if n_variable < 1\n"
	"r_op = r_val  = nil\n"
	"g_op = g_val = nil\n"
	"b_op = b_val = nil\n"
	"if r2 > r\n"
	"r_op, r_val = :+, r2.-(r)./(n_variable.to_f)\n"
	"elsif r2 < r\n"
	"r_op, r_val = :-, r.-(r2)./(n_variable.to_f)\n"
	"end\n"
	"if g2 > g\n"
	"g_op, g_val = :+, g2.-(g)./(n_variable.to_f)\n"
	"elsif g2 < g\n"
	"g_op, g_val = :-, g.-(g2)./(n_variable.to_f)\n"
	"end\n"
	"if b2 > b\n"
	"b_op, b_val = :+, b2.-(b)./(n_variable.to_f)\n"
	"elsif b2 < b\n"
	"b_op, b_val = :-, b.-(b2)./(n_variable.to_f)\n"
	"end\n"
	"_r = _r.send(r_op, r_val * -1) if r_op\n"
	"_g = _g.send(g_op, g_val * -1) if g_op\n"
	"_b = _b.send(b_op, b_val * -1) if b_op\n"
	"i = -1\n"
	"while (i += 1) < len\n"
	"_c = c[i]\n"
	"if !exclude_spaces || (_c != space && _c != tab)\n"
	"_r = _r.send(r_op, r_val) if r_op\n"
	"_g = _g.send(g_op, g_val) if g_op\n"
	"_b = _b.send(b_op, b_val) if b_op\n"
	"end\n"
	"r_to_i = _r.to_i\n"
	"g_to_i = _g.to_i\n"
	"b_to_i = _b.to_i\n"
	"clamped_r = r_to_i < 0 ? 0 : r_to_i > 255 ? 255 : r_to_i\n"
	"clamped_g = g_to_i < 0 ? 0 : g_to_i > 255 ? 255 : g_to_i\n"
	"clamped_b = b_to_i < 0 ? 0 : b_to_i > 255 ? 255 : b_to_i\n"
	"ret = \"\\e[#{init};2;#{clamped_r};#{clamped_g};#{clamped_b}m#{_c}\"\n"
	"temp << ret\n"
	"end\n"
	"ret = if !c.empty?\n"
	"chomped ? \"\\e[0m\\n\".freeze : \"\\e[0m\".freeze\n"
	"elsif chomped\n"
	"?\\n.freeze\n"
	"end\n"
	"temp << ret\n"
	"if rotate\n"
	"all_rgbs.rotate!\n"
	"r, g, b = all_rgbs[0]\n"
	"r2, g2, b2 = all_rgbs[1]\n"
	"end\n"
	"end\n"
	"temp\n"
	"end\n"
	"def multi_gradient(*colours,\n"
	"exclude_spaces: true,\n"
	"bg: false,\n"
	"bold: false,\n"
	"italic: false,\n"
	"underline: false,\n"
	"blink: false,\n"
	"strikethrough: false,\n"
	"double_underline: false,\n"
	"overline: false,\n"
	"&block\n"
	")\n"
	"len = colours.length\n"
	"raise ArgumentError, \"Minimum two colours are required, given #{len}\" if len < 2\n"
	"div = len - 1\n"
	"div_1 = div - 1\n"
	"ret = ''\n"
	"block_given = block_given?\n"
	"params = {\n"
	"exclude_spaces: exclude_spaces,\n"
	"bg: bg,\n"
	"bold: bold,\n"
	"italic: italic,\n"
	"underline: underline,\n"
	"blink: blink,\n"
	"strikethrough: strikethrough,\n"
	"double_underline: double_underline,\n"
	"overline: overline,\n"
	"}\n"
	"lines { |l|\n"
	"_len = l.length\n"
	"len, c = _len./(div.to_f).round, colours.dup\n"
	"counter, i, j = -1, -1, 0\n"
	"ch = ''\n"
	"while x = l[i += 1] do\n"
	"counter += 1\n"
	"if counter == len && j < div_1\n"
	"counter, j = 0, j + 1\n"
	"ret << ch.gradient(c[0], c[1], **params)\n"
	"c.rotate!\n"
	"ch.clear\n"
	"end\n"
	"ch << x\n"
	"end\n"
	"ret << ch.gradient(c[0], c[1], **params)\n"
	"}\n"
	"ret\n"
	"end\n"
	"end\n"
	"c = [\n"
	"0x00c0ff, 0xffff40, 0xff8359,\n"
	"0x59c2ff, 0x1270e3, 0x15eded,\n"
	"0x029cf5, 0xff7cce,\n"
	"0xf5317f, 0xb122e5\n"
	"]\n"
	"File.open(TMPFILE, 'w').write('0') rescue nil unless File.exist?(TMPFILE)\n"
	"value = File.read(TMPFILE).to_i % c.length rescue nil\n"
	"File.open(TMPFILE, 'w').write(value.+(1).to_s) rescue nil\n"
	"c.rotate!(value)\n"
	"print %Q(\\u256d\\u2504\\u2504[#{logname}\\u02d0\\u02d0#{hostname}]\\u2505).multi_gradient(c.shift, c.shift, c.shift) <<\n"
	"%Q([#{PWD}]).multi_gradient(c.shift, c.shift, c.shift, bold: true) <<\n"
	"%Q(\\u2505[#{children} item#{children == 1 ? '' : 's'}]).multi_gradient(c.shift, c.shift) <<\n"
	"%Q(\\u2505[#{current_time}]).multi_gradient(c.shift, c.shift) <<\n"
	"%Q(\\n\\u2570\\u2500\\u2500\\u257c\\u2b9a\\s)\n"
);}
