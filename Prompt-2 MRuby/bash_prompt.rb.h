char *code() { return(

	"###### CPrompt from C File ######\n"
	"PWD = CPrompt.get_pwd\n"
	"hostname = CPrompt.get_hostname\n"
	"logname = CPrompt.get_logname\n"
	"current_time = CPrompt.get_current_time\n"
	"children = CPrompt.count_files\n"
	"\n"
	"###### Test ######\n"
	"#~ PWD = 'pwd'\n"
	"#~ hostname = 'hostname'\n"
	"#~ logname = 'logname'\n"
	"#~ current_time = Time.now\n"
	"#~ children = 50\n"
	"\n"
	"TMPFILE = \"/tmp/bash_prompt_#{logname}.lock\"\n"
	"\n"
	"class String\n"
	"\t# Fast conversion to RGB when Integer is passed.\n"
	"\t# For example: 0xffffff for white,\n"
	"\t# 0x000000 or 0x0 for black, 0x00aa00 for deep green\n"
	"\t# 0xff50a6 for pink, 0xff5555 for light red, etc.\n"
	"\t#\n"
	"\t# Similarly:\n"
	"\t# (255 * 256 * 256) + (255 * 256) + (255) => 0xffffff\n"
	"\t# (0 * 256 * 256) + (0 * 256) + 0 => 0x0\n"
	"\t# (255 * 256 * 256) + (85 * 256) + 85 => #ff5555\n"
	"\t# (85 * 256 * 256) + (85 * 256) + 255 => #5555ff\n"
	"\t# (255 * 256 * 256) + (170 * 256) + 0 => 0xffaa00\n"
	"\t# (0 * 256 * 256) + (170 * 256) + 0 => 0x00aa00\n"
	"\tdef hex_to_rgb(hex)\n"
	"\t\treturn [\n"
	"\t\t\t255 & hex >> 16,\n"
	"\t\t\t255 & hex >> 8,\n"
	"\t\t\t255 & hex\n"
	"\t\t] if hex.is_a?(Integer)\n"
	"\n"
	"\t\t# Duplicate colour, even if colour is nil\n"
	"\t\t# This workaround is for Ruby 2.0 to Ruby 2.2\n"
	"\t\t# Which won't allow duplicate nil.\n"
	"\t\tcolour = hex && hex.dup.to_s || ''\n"
	"\t\tcolour.strip!\n"
	"\t\tcolour.downcase!\n"
	"\t\tcolour[0] = ''.freeze if colour[0] == ?#.freeze\n"
	"\n"
	"\t\t# out of range\n"
	"\t\toor = colour.scan(/[^a-f0-9]/)\n"
	"\n"
	"\t\tunless oor.empty?\n"
	"\t\t\tinvalids = colour.chars.map { |x|\n"
	"\t\t\t\toor.include?(x) ? \"\\e[1;31m#{x}\\e[0m\" : x\n"
	"\t\t\t}.join\n"
	"\n"
	"\t\t\traise ArgumentError, \"\\e[0mHex Colour \\e[1m##{invalids} is Out of Range\\e[0m\"\n"
	"\t\tend\n"
	"\n"
	"\t\tclen = colour.length\n"
	"\n"
	"\t\tif clen == 3\n"
	"\t\t\tcolour.chars.map { |x| x.<<(x).to_i(16) }\n"
	"\t\telsif clen == 6\n"
	"\t\t\tcolour.chars.each_slice(2).map { |x| x.join.to_i(16) }\n"
	"\t\telse\n"
	"\t\t\tsli = clen > 6 ? 'too long'.freeze : clen < 3 ? 'too short'.freeze : 'invalid'.freeze\n"
	"\t\t\traise ArgumentError, \"Invalid Hex Colour ##{colour} (length #{sli})\"\n"
	"\t\tend\n"
	"\tend\n"
	"\n"
	"\t##\n"
	"\t# = gradient(*arg_colours, bg: false, exclude_spaces: true, bold: false, blink: false)    # => string or nil\n"
	"\t#\n"
	"\t# Prettifies your string by adding gradient colours.\n"
	"\t#\n"
	"\t# This method accept a lot of colours. For example:\n"
	"\t#\n"
	"\t# 1. puts \"Hello\".gradient('#f55', '#55f')\n"
	"\t# This will add #f55 (red) to #55f (blue) gradient colours to your texts.\n"
	"\t#\n"
	"\t# 2. puts \"Hello\\nWorld\".gradient('#f55', '#55f')\n"
	"\t# This will add #f55 (red) to #55f (blue) gradient colours to your texts, spanning multiple lines.\n"
	"\t#\n"
	"\t# 3. puts \"Hello\\nWorld!\\nColours\\nare\\nrotated here\".gradient('f55','55f', '3eb' 'ff5')\n"
	"\t# This will add #ff5555 (red) to #5555ff (blue) gradient colours to the first line,\n"
	"\t# 5555ff to 33eebb colour to the 2nd line,\n"
	"\t# 33eebb to ffff55 to the third line\n"
	"\t# And then back to ffff55 to ff5555 to the fourth line,\n"
	"\t# And it will continue to rotate between these colours.\n"
	"\t#\n"
	"\t# To stop rotating, just don't give more than two arguments to this method.\n"
	"\t#\n"
	"\t# Passing blocks is also optional, and is handy for animating text. For example:\n"
	"\t#    \"Hello\\nWorld!\\nColours\\nare\\nrotated here\".gradient('f55','55f', '3eb' 'ff5', bg:true) { |x| print x ; sleep 0.05 }\n"
	"\t#\n"
	"\t# This will pass the values to the block itself, and will draw the colourful text slowly.\n"
	"\t# Passing block will return nil from the method because the values will be passed to the block variable instead.\n"
	"\t#\n"
	"\t# Adding the option bg will change the background colour, but will keep the foreground colour\n"
	"\t# defined in the terminal settings.\n"
	"\t#\n"
	"\t# The option exclude_spaces, is expected to set either true or false.\n"
	"\t# By default it's set to true.\n"
	"\t# Enabling this option will not waste colours on white-spaces.\n"
	"\t# White spaces only include: \\s, \\t\n"
	"\t#\n"
	"\t# Please do note that \\u0000 and \\r in the middle of the string will not be\n"
	"\t# counted as a white space, but as a character instead.\n"
	"\t# This is because \\r wipes out the previous characters, and using \\u0000 in\n"
	"\t# a string is uncommon, and developers are requested to delete\n"
	"\t# \\u0000 from string if such situations arise.\n"
	"\t#\n"
	"\t# The option bold makes texts bold, but it also makes the string bigger.\n"
	"\t# Set bold to anything truthy or falsey, but better just go with true and false or nil\n"
	"\t#\n"
	"\t# The option blink makes the texts blink on supported terminals.\n"
	"\t# Set blink to anything truthy or falsey, but better just go with true and false or nil\n"
	"\tdef gradient(*arg_colours,\n"
	"\t\texclude_spaces: true,\n"
	"\t\tbg: false,\n"
	"\t\tbold: false,\n"
	"\t\titalic: false,\n"
	"\t\tunderline: false,\n"
	"\t\tblink: false,\n"
	"\t\tstrikethrough: false,\n"
	"\t\tdouble_underline: false,\n"
	"\t\toverline: false\n"
	"\t\t)\n"
	"\n"
	"\t\tspace, tab = ?\\s.freeze, ?\\t.freeze\n"
	"\n"
	"\t\tblock_given = block_given?\n"
	"\t\ttemp = ''\n"
	"\t\tflatten_colours = arg_colours.flatten\n"
	"\n"
	"\t\t# Create the styling here rather than creating it in the each_line loop\n"
	"\t\t# We also make it a bit different, rather than using \\e[1m\\e[5m, we will do\n"
	"\t\t# \\e[1;5m to save the number of characters spit out by this method\n"
	"\t\tstyle = nil\n"
	"\n"
	"\t\tif bold || italic || underline || blink || strikethrough || double_underline || overline\n"
	"\t\t\tstyle = \"\\e[\"\n"
	"\n"
	"\t\t\tstyle << '1;'.freeze if bold\n"
	"\t\t\tstyle << '3;'.freeze if italic\n"
	"\t\t\tstyle << '4;'.freeze if underline\n"
	"\t\t\tstyle << '5;'.freeze if blink\n"
	"\t\t\tstyle << '9;'.freeze if strikethrough\n"
	"\t\t\tstyle << '21;'.freeze if double_underline\n"
	"\t\t\tstyle << '53;'.freeze if overline\n"
	"\n"
	"\t\t\tstyle.chop!\n"
	"\t\t\tstyle << ?m.freeze\n"
	"\t\tend\n"
	"\n"
	"\t\traise ArgumentError, \"Wrong numeber of colours (given #{flatten_colours.length}, expected minimum 2)\" if flatten_colours.length < 2\n"
	"\t\traise ArgumentError, \"Given argument for colour is neither a String nor an Integer\" if flatten_colours.any? { |x| !(x.is_a?(String) || x.is_a?(Integer)) }\n"
	"\n"
	"\t\tall_rgbs = flatten_colours.map!(&method(:hex_to_rgb))\n"
	"\n"
	"\t\tyield style if block_given && style\n"
	"\n"
	"\t\t# r, g, b => starting r, g, b\n"
	"\t\t# r2, g2, b2 => stopping r, g, b\n"
	"\t\tr, g, b = *all_rgbs[0]\n"
	"\t\tr2, g2, b2 = *all_rgbs[1]\n"
	"\t\trotate = all_rgbs.length > 2\n"
	"\n"
	"\t\tinit = bg ? 48 : 38\n"
	"\n"
	"\t\tlines do |c|\n"
	"\t\t\ttemp << style if style\n"
	"\n"
	"\t\t\t_r, _g, _b = r, g, b\n"
	"\t\t\tchomped = !!c.chomp!(''.freeze)\n"
	"\n"
	"\t\t\tlen = c.length\n"
	"\t\t\tn_variable = exclude_spaces ? c.delete(\"\\t\\s\".freeze).length : len\n"
	"\t\t\tn_variable -= 1\n"
	"\t\t\tn_variable = 1 if n_variable < 1\n"
	"\n"
	"\t\t\t# colour operator, colour value\n"
	"\t\t\t#\n"
	"\t\t\t# r_op, g_op, b_op are also flags to determine\n"
	"\t\t\t# if the r, g, and b values respectively should change or not\n"
	"\t\t\t# For example, if the given blues are equal, the b_op is nil\n"
	"\t\t\t# So it won't change the colour in the ouput\n"
	"\t\t\tr_op = r_val  = nil\n"
	"\t\t\tg_op = g_val = nil\n"
	"\t\t\tb_op = b_val = nil\n"
	"\n"
	"\t\t\tif r2 > r\n"
	"\t\t\t\tr_op, r_val = :+, r2.-(r)./(n_variable.to_f)\n"
	"\t\t\telsif r2 < r\n"
	"\t\t\t\tr_op, r_val = :-, r.-(r2)./(n_variable.to_f)\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\tif g2 > g\n"
	"\t\t\t\tg_op, g_val = :+, g2.-(g)./(n_variable.to_f)\n"
	"\t\t\telsif g2 < g\n"
	"\t\t\t\tg_op, g_val = :-, g.-(g2)./(n_variable.to_f)\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\tif b2 > b\n"
	"\t\t\t\tb_op, b_val = :+, b2.-(b)./(n_variable.to_f)\n"
	"\t\t\telsif b2 < b\n"
	"\t\t\t\tb_op, b_val = :-, b.-(b2)./(n_variable.to_f)\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\t# To avoid the value getting adding | subtracted from the initial character\n"
	"\t\t\t_r = _r.send(r_op, r_val * -1) if r_op\n"
	"\t\t\t_g = _g.send(g_op, g_val * -1) if g_op\n"
	"\t\t\t_b = _b.send(b_op, b_val * -1) if b_op\n"
	"\n"
	"\t\t\ti = -1\n"
	"\t\t\twhile (i += 1) < len\n"
	"\t\t\t\t_c = c[i]\n"
	"\n"
	"\t\t\t\tif !exclude_spaces || (_c != space && _c != tab)\n"
	"\t\t\t\t\t_r = _r.send(r_op, r_val) if r_op\n"
	"\t\t\t\t\t_g = _g.send(g_op, g_val) if g_op\n"
	"\t\t\t\t\t_b = _b.send(b_op, b_val) if b_op\n"
	"\t\t\t\tend\n"
	"\n"
	"\t\t\t\tr_to_i = _r.to_i\n"
	"\t\t\t\tg_to_i = _g.to_i\n"
	"\t\t\t\tb_to_i = _b.to_i\n"
	"\n"
	"\t\t\t\tclamped_r = r_to_i < 0 ? 0 : r_to_i > 255 ? 255 : r_to_i\n"
	"\t\t\t\tclamped_g = g_to_i < 0 ? 0 : g_to_i > 255 ? 255 : g_to_i\n"
	"\t\t\t\tclamped_b = b_to_i < 0 ? 0 : b_to_i > 255 ? 255 : b_to_i\n"
	"\n"
	"\t\t\t\tret = \"\\e[#{init};2;#{clamped_r};#{clamped_g};#{clamped_b}m#{_c}\"\n"
	"\n"
	"\t\t\t\t# if block_given\n"
	"\t\t\t\t\t# yield ret\n"
	"\t\t\t\t# else\n"
	"\t\t\t\t\ttemp << ret\n"
	"\t\t\t\t# end\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\tret = if !c.empty?\n"
	"\t\t\t\tchomped ? \"\\e[0m\\n\".freeze : \"\\e[0m\".freeze\n"
	"\t\t\telsif chomped\n"
	"\t\t\t\t?\\n.freeze\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\ttemp << ret\n"
	"\n"
	"\t\t\tif rotate\n"
	"\t\t\t\tall_rgbs.rotate!\n"
	"\t\t\t\tr, g, b = all_rgbs[0]\n"
	"\t\t\t\tr2, g2, b2 = all_rgbs[1]\n"
	"\t\t\tend\n"
	"\t\tend\n"
	"\n"
	"\t\ttemp\n"
	"\tend\n"
	"\n"
	"\t##\n"
	"\t# = multi_gradient(*n_arg_colours, bg: false, exclude_spaces: true, bold: false, blink: false)    # => string or nil\n"
	"\t#\n"
	"\t# Accepts n number of colours. Example:\n"
	"\t#    'Hello world this is multi_gradient()'.multi_gradient('3eb', '55f', 'f55', 'fa0')\n"
	"\t#\n"
	"\t# In this example, multi_gradient() paints the string with 4 colours in one line.\n"
	"\t#\n"
	"\t# It Splits up a string with the Calls String#gradient() with the given number of colours\n"
	"\t# So each call to multi_gradient() involves many calls to String#gradient().\n"
	"\t# Hence it's slower than String#gradient()\n"
	"\tdef multi_gradient(*colours,\n"
	"\t\texclude_spaces: true,\n"
	"\t\tbg: false,\n"
	"\t\tbold: false,\n"
	"\t\titalic: false,\n"
	"\t\tunderline: false,\n"
	"\t\tblink: false,\n"
	"\t\tstrikethrough: false,\n"
	"\t\tdouble_underline: false,\n"
	"\t\toverline: false,\n"
	"\t\t&block\n"
	"\t\t)\n"
	"\n"
	"\t\tlen = colours.length\n"
	"\t\traise ArgumentError, \"Minimum two colours are required, given #{len}\" if len < 2\n"
	"\n"
	"\t\tdiv = len - 1\n"
	"\t\tdiv_1 = div - 1\n"
	"\t\tret = ''\n"
	"\t\tblock_given = block_given?\n"
	"\n"
	"\t\tparams = {\n"
	"\t\t\texclude_spaces: exclude_spaces,\n"
	"\t\t\tbg: bg,\n"
	"\t\t\tbold: bold,\n"
	"\t\t\titalic: italic,\n"
	"\t\t\tunderline: underline,\n"
	"\t\t\tblink: blink,\n"
	"\t\t\tstrikethrough: strikethrough,\n"
	"\t\t\tdouble_underline: double_underline,\n"
	"\t\t\toverline: overline,\n"
	"\t\t}\n"
	"\n"
	"\t\tlines { |l|\n"
	"\t\t\t_len = l.length\n"
	"\n"
	"\t\t\tlen, c = _len./(div.to_f).round, colours.dup\n"
	"\t\t\tcounter, i, j = -1, -1, 0\n"
	"\t\t\tch = ''\n"
	"\n"
	"\t\t\twhile x = l[i += 1] do\n"
	"\t\t\t\tcounter += 1\n"
	"\n"
	"\t\t\t\t# colour % len == 0 is very slow approach\n"
	"\t\t\t\tif counter == len && j < div_1\n"
	"\t\t\t\t\tcounter, j = 0, j + 1\n"
	"\t\t\t\t\tret << ch.gradient(c[0], c[1], **params)\n"
	"\t\t\t\t\tc.rotate!\n"
	"\t\t\t\t\tch.clear\n"
	"\t\t\t\tend\n"
	"\n"
	"\t\t\t\tch << x\n"
	"\t\t\tend\n"
	"\n"
	"\t\t\tret << ch.gradient(c[0], c[1], **params)\n"
	"\t\t}\n"
	"\n"
	"\t\tret\n"
	"\tend\n"
	"end\n"
	"\n"
	"c = [\n"
	"\t0x00c0ff, 0xffff40, 0xff8359,\n"
	"\t0x59c2ff, 0x1270e3, 0x15eded,\n"
	"\t0x029cf5, 0xff7cce,\n"
	"\t0xf5317f, 0xb122e5\n"
	"]\n"
	"\n"
	"File.open(TMPFILE, 'w').write('0') rescue nil unless File.exist?(TMPFILE)\n"
	"value = File.read(TMPFILE).to_i % c.length rescue nil\n"
	"File.open(TMPFILE, 'w').write(value.+(1).to_s) rescue nil\n"
	"c.rotate!(value)\n"
	"\n"
	"print %Q(\\u256d\\u2504\\u2504[#{logname}\\u02d0\\u02d0#{hostname}]\\u2505).multi_gradient(c.shift, c.shift, c.shift) <<\n"
	"\t%Q([#{PWD}]).multi_gradient(c.shift, c.shift, c.shift, bold: true) <<\n"
	"\t%Q(\\u2505[#{children} item#{children == 1 ? '' : 's'}]).multi_gradient(c.shift, c.shift) <<\n"
	"\t%Q(\\u2505[#{current_time}]).multi_gradient(c.shift, c.shift) <<\n"
	"\t%Q(\\n\\u2570\\u2500\\u2500\\u257c\\u2b9a\\s)\n"

);}