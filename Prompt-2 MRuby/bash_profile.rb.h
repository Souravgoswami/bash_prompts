char *code() { return(
	"###### CPrompt from "
   "C File ######\r\n"
   "PWD = CPrompt.get_pw"
   "d\r\n"
   "hostname = CPrompt.g"
   "et_hostname\r\n"
   "logname = CPrompt.ge"
   "t_logname\r\n"
   "current_time = CProm"
   "pt.get_current_time"
   "\r\n"
   "children = CPrompt.c"
   "ount_files\r\n\r\n"
   "###### Test ######\r"
   "\n"
   "#~ PWD = \'pwd\'\r\n"
   "#~ hostname = \'host"
   "name\'\r\n"
   "#~ logname = \'logna"
   "me\'\r\n"
   "#~ current_time = Ti"
   "me.now\r\n"
   "#~ children = 50\r\n"
   "\r\n"
   "TMPFILE = \"/tmp/bas"
   "h_prompt_#{logname}."
   "lock\"\r\n\r\n"
   "class String\r\n"
   "\t# Fast conversion "
   "to RGB when Integer "
   "is passed.\r\n"
   "\t# For example: 0xf"
   "fffff for white,\r\n"
   "\t# 0x000000 or 0x0 "
   "for black, 0x00aa00 "
   "for deep green\r\n"
   "\t# 0xff50a6 for pin"
   "k, 0xff5555 for ligh"
   "t red, etc.\r\n"
   "\t#\r\n"
   "\t# Similarly:\r\n"
   "\t# (255 * 256 * 256"
   ") + (255 * 256) + (2"
   "55) => 0xffffff\r\n"
   "\t# (0 * 256 * 256) "
   "+ (0 * 256) + 0 => 0"
   "x0\r\n"
   "\t# (255 * 256 * 256"
   ") + (85 * 256) + 85 "
   "=> #ff5555\r\n"
   "\t# (85 * 256 * 256)"
   " + (85 * 256) + 255 "
   "=> #5555ff\r\n"
   "\t# (255 * 256 * 256"
   ") + (170 * 256) + 0 "
   "=> 0xffaa00\r\n"
   "\t# (0 * 256 * 256) "
   "+ (170 * 256) + 0 =>"
   " 0x00aa00\r\n"
   "\tdef hex_to_rgb(hex"
   ")\r\n"
   "\t\treturn [\r\n"
   "\t\t\t255 & hex >> 1"
   "6,\r\n"
   "\t\t\t255 & hex >> 8"
   ",\r\n"
   "\t\t\t255 & hex\r\n"
   "\t\t] if hex.is_a?(I"
   "nteger)\r\n\r\n"
   "\t\t# Duplicate colo"
   "ur, even if colour i"
   "s nil\r\n"
   "\t\t# This workaroun"
   "d is for Ruby 2.0 to"
   " Ruby 2.2\r\n"
   "\t\t# Which won\'t a"
   "llow duplicate nil."
   "\r\n"
   "\t\tcolour = hex && "
   "hex.dup.to_s || \'\'"
   "\r\n"
   "\t\tcolour.strip!\r"
   "\n"
   "\t\tcolour.downcase!"
   "\r\n"
   "\t\tcolour[0] = \'\'"
   ".freeze if colour[0]"
   " == ?#.freeze\r\n\r"
   "\n"
   "\t\t# out of range\r"
   "\n"
   "\t\toor = colour.sca"
   "n(/[^a-f0-9]/)\r\n\r"
   "\n"
   "\t\tunless oor.empty"
   "?\r\n"
   "\t\t\tinvalids = col"
   "our.chars.map { |x|"
   "\r\n"
   "\t\t\t\toor.include?"
   "(x) ? \"\\e[1;31m#{x"
   "}\\e[0m\" : x\r\n"
   "\t\t\t}.join\r\n\r\n"
   "\t\t\traise Argument"
   "Error, \"\\e[0mHex C"
   "olour \\e[1m##{inval"
   "ids} is Out of Range"
   "\\e[0m\"\r\n"
   "\t\tend\r\n\r\n"
   "\t\tclen = colour.le"
   "ngth\r\n\r\n"
   "\t\tif clen == 3\r\n"
   "\t\t\tcolour.chars.m"
   "ap { |x| x.<<(x).to_"
   "i(16) }\r\n"
   "\t\telsif clen == 6"
   "\r\n"
   "\t\t\tcolour.chars.e"
   "ach_slice(2).map { |"
   "x| x.join.to_i(16) }"
   "\r\n"
   "\t\telse\r\n"
   "\t\t\tsli = clen > 6"
   " ? \'too long\'.free"
   "ze : clen < 3 ? \'to"
   "o short\'.freeze : "
   "\'invalid\'.freeze\r"
   "\n"
   "\t\t\traise Argument"
   "Error, \"Invalid Hex"
   " Colour ##{colour} ("
   "length #{sli})\"\r\n"
   "\t\tend\r\n"
   "\tend\r\n\r\n"
   "\t##\r\n"
   "\t# = gradient(*arg_"
   "colours, bg: false, "
   "exclude_spaces: true"
   ", bold: false, blink"
   ": false)    # => str"
   "ing or nil\r\n"
   "\t#\r\n"
   "\t# Prettifies your "
   "string by adding gra"
   "dient colours.\r\n"
   "\t#\r\n"
   "\t# This method acce"
   "pt a lot of colours."
   " For example:\r\n"
   "\t#\r\n"
   "\t# 1. puts \"Hello"
   "\".gradient(\'#f55\'"
   ", \'#55f\')\r\n"
   "\t# This will add #f"
   "55 (red) to #55f (bl"
   "ue) gradient colours"
   " to your texts.\r\n"
   "\t#\r\n"
   "\t# 2. puts \"Hello"
   "\\nWorld\".gradient("
   "\'#f55\', \'#55f\')"
   "\r\n"
   "\t# This will add #f"
   "55 (red) to #55f (bl"
   "ue) gradient colours"
   " to your texts, span"
   "ning multiple lines."
   "\r\n"
   "\t#\r\n"
   "\t# 3. puts \"Hello"
   "\\nWorld!\\nColours"
   "\\nare\\nrotated her"
   "e\".gradient(\'f55\'"
   ",\'55f\', \'3eb\' \'"
   "ff5\')\r\n"
   "\t# This will add #f"
   "f5555 (red) to #5555"
   "ff (blue) gradient c"
   "olours to the first "
   "line,\r\n"
   "\t# 5555ff to 33eebb"
   " colour to the 2nd l"
   "ine,\r\n"
   "\t# 33eebb to ffff55"
   " to the third line\r"
   "\n"
   "\t# And then back to"
   " ffff55 to ff5555 to"
   " the fourth line,\r"
   "\n"
   "\t# And it will cont"
   "inue to rotate betwe"
   "en these colours.\r"
   "\n"
   "\t#\r\n"
   "\t# To stop rotating"
   ", just don\'t give m"
   "ore than two argumen"
   "ts to this method.\r"
   "\n"
   "\t#\r\n"
   "\t# Passing blocks i"
   "s also optional, and"
   " is handy for animat"
   "ing text. For exampl"
   "e:\r\n"
   "\t#    \"Hello\\nWor"
   "ld!\\nColours\\nare"
   "\\nrotated here\".gr"
   "adient(\'f55\',\'55f"
   "\', \'3eb\' \'ff5\',"
   " bg:true) { |x| prin"
   "t x ; sleep 0.05 }\r"
   "\n"
   "\t#\r\n"
   "\t# This will pass t"
   "he values to the blo"
   "ck itself, and will "
   "draw the colourful t"
   "ext slowly.\r\n"
   "\t# Passing block wi"
   "ll return nil from t"
   "he method because th"
   "e values will be pas"
   "sed to the block var"
   "iable instead.\r\n"
   "\t#\r\n"
   "\t# Adding the optio"
   "n bg will change the"
   " background colour, "
   "but will keep the fo"
   "reground colour\r\n"
   "\t# defined in the t"
   "erminal settings.\r"
   "\n"
   "\t#\r\n"
   "\t# The option exclu"
   "de_spaces, is expect"
   "ed to set either tru"
   "e or false.\r\n"
   "\t# By default it\'s"
   " set to true.\r\n"
   "\t# Enabling this op"
   "tion will not waste "
   "colours on white-spa"
   "ces.\r\n"
   "\t# White spaces onl"
   "y include: \\s, \\t"
   "\r\n"
   "\t#\r\n"
   "\t# Please do note t"
   "hat \\u0000 and \\r "
   "in the middle of the"
   " string will not be"
   "\r\n"
   "\t# counted as a whi"
   "te space, but as a c"
   "haracter instead.\r"
   "\n"
   "\t# This is because "
   "\\r wipes out the pr"
   "evious characters, a"
   "nd using \\u0000 in"
   "\r\n"
   "\t# a string is unco"
   "mmon, and developers"
   " are requested to de"
   "lete\r\n"
   "\t# \\u0000 from str"
   "ing if such situatio"
   "ns arise.\r\n"
   "\t#\r\n"
   "\t# The option bold "
   "makes texts bold, bu"
   "t it also makes the "
   "string bigger.\r\n"
   "\t# Set bold to anyt"
   "hing truthy or false"
   "y, but better just g"
   "o with true and fals"
   "e or nil\r\n"
   "\t#\r\n"
   "\t# The option blink"
   " makes the texts bli"
   "nk on supported term"
   "inals.\r\n"
   "\t# Set blink to any"
   "thing truthy or fals"
   "ey, but better just "
   "go with true and fal"
   "se or nil\r\n"
   "\tdef gradient(*arg_"
   "colours,\r\n"
   "\t\texclude_spaces: "
   "true,\r\n"
   "\t\tbg: false,\r\n"
   "\t\tbold: false,\r\n"
   "\t\titalic: false,\r"
   "\n"
   "\t\tunderline: false"
   ",\r\n"
   "\t\tblink: false,\r"
   "\n"
   "\t\tstrikethrough: f"
   "alse,\r\n"
   "\t\tdouble_underline"
   ": false,\r\n"
   "\t\toverline: false"
   "\r\n"
   "\t\t)\r\n\r\n"
   "\t\tspace, tab = ?\\"
   "s.freeze, ?\\t.freez"
   "e\r\n\r\n"
   "\t\tblock_given = bl"
   "ock_given?\r\n"
   "\t\ttemp = \'\'\r\n"
   "\t\tflatten_colours "
   "= arg_colours.flatte"
   "n\r\n\r\n"
   "\t\t# Create the sty"
   "ling here rather tha"
   "n creating it in the"
   " each_line loop\r\n"
   "\t\t# We also make i"
   "t a bit different, r"
   "ather than using \\e"
   "[1m\\e[5m, we will d"
   "o\r\n"
   "\t\t# \\e[1;5m to sa"
   "ve the number of cha"
   "racters spit out by "
   "this method\r\n"
   "\t\tstyle = nil\r\n"
   "\r\n"
   "\t\tif bold || itali"
   "c || underline || bl"
   "ink || strikethrough"
   " || double_underline"
   " || overline\r\n"
   "\t\t\tstyle = \"\\e["
   "\"\r\n\r\n"
   "\t\t\tstyle << \'1;"
   "\'.freeze if bold\r"
   "\n"
   "\t\t\tstyle << \'3;"
   "\'.freeze if italic"
   "\r\n"
   "\t\t\tstyle << \'4;"
   "\'.freeze if underli"
   "ne\r\n"
   "\t\t\tstyle << \'5;"
   "\'.freeze if blink\r"
   "\n"
   "\t\t\tstyle << \'9;"
   "\'.freeze if striket"
   "hrough\r\n"
   "\t\t\tstyle << \'21;"
   "\'.freeze if double_"
   "underline\r\n"
   "\t\t\tstyle << \'53;"
   "\'.freeze if overlin"
   "e\r\n\r\n"
   "\t\t\tstyle.chop!\r"
   "\n"
   "\t\t\tstyle << ?m.fr"
   "eeze\r\n"
   "\t\tend\r\n\r\n"
   "\t\traise ArgumentEr"
   "ror, \"Wrong numeber"
   " of colours (given #"
   "{flatten_colours.len"
   "gth}, expected minim"
   "um 2)\" if flatten_c"
   "olours.length < 2\r"
   "\n"
   "\t\traise ArgumentEr"
   "ror, \"Given argumen"
   "t for colour is neit"
   "her a String nor an "
   "Integer\" if flatten"
   "_colours.any? { |x| "
   "!(x.is_a?(String) ||"
   " x.is_a?(Integer)) }"
   "\r\n\r\n"
   "\t\tall_rgbs = flatt"
   "en_colours.map!(&met"
   "hod(:hex_to_rgb))\r"
   "\n\r\n"
   "\t\tyield style if b"
   "lock_given && style"
   "\r\n\r\n"
   "\t\t# r, g, b => sta"
   "rting r, g, b\r\n"
   "\t\t# r2, g2, b2 => "
   "stopping r, g, b\r\n"
   "\t\tr, g, b = *all_r"
   "gbs[0]\r\n"
   "\t\tr2, g2, b2 = *al"
   "l_rgbs[1]\r\n"
   "\t\trotate = all_rgb"
   "s.length > 2\r\n\r\n"
   "\t\tinit = bg ? 48 :"
   " 38\r\n\r\n"
   "\t\tlines do |c|\r\n"
   "\t\t\ttemp << style "
   "if style\r\n\r\n"
   "\t\t\t_r, _g, _b = r"
   ", g, b\r\n"
   "\t\t\tchomped = !!c."
   "chomp!(\'\'.freeze)"
   "\r\n\r\n"
   "\t\t\tlen = c.length"
   "\r\n"
   "\t\t\tn_variable = e"
   "xclude_spaces ? c.de"
   "lete(\"\\t\\s\".free"
   "ze).length : len\r\n"
   "\t\t\tn_variable -= "
   "1\r\n"
   "\t\t\tn_variable = 1"
   " if n_variable < 1\r"
   "\n\r\n"
   "\t\t\t# colour opera"
   "tor, colour value\r"
   "\n"
   "\t\t\t#\r\n"
   "\t\t\t# r_op, g_op, "
   "b_op are also flags "
   "to determine\r\n"
   "\t\t\t# if the r, g,"
   " and b values respec"
   "tively should change"
   " or not\r\n"
   "\t\t\t# For example,"
   " if the given blues "
   "are equal, the b_op "
   "is nil\r\n"
   "\t\t\t# So it won\'t"
   " change the colour i"
   "n the ouput\r\n"
   "\t\t\tr_op = r_val  "
   "= nil\r\n"
   "\t\t\tg_op = g_val ="
   " nil\r\n"
   "\t\t\tb_op = b_val ="
   " nil\r\n\r\n"
   "\t\t\tif r2 > r\r\n"
   "\t\t\t\tr_op, r_val "
   "= :+, r2.-(r)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\telsif r2 < r\r"
   "\n"
   "\t\t\t\tr_op, r_val "
   "= :-, r.-(r2)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\tif g2 > g\r\n"
   "\t\t\t\tg_op, g_val "
   "= :+, g2.-(g)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\telsif g2 < g\r"
   "\n"
   "\t\t\t\tg_op, g_val "
   "= :-, g.-(g2)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\tif b2 > b\r\n"
   "\t\t\t\tb_op, b_val "
   "= :+, b2.-(b)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\telsif b2 < b\r"
   "\n"
   "\t\t\t\tb_op, b_val "
   "= :-, b.-(b2)./(n_va"
   "riable.to_f)\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\t# To avoid the"
   " value getting addin"
   "g | subtracted from "
   "the initial characte"
   "r\r\n"
   "\t\t\t_r = _r.send(r"
   "_op, r_val * -1) if "
   "r_op\r\n"
   "\t\t\t_g = _g.send(g"
   "_op, g_val * -1) if "
   "g_op\r\n"
   "\t\t\t_b = _b.send(b"
   "_op, b_val * -1) if "
   "b_op\r\n\r\n"
   "\t\t\ti = -1\r\n"
   "\t\t\twhile (i += 1)"
   " < len\r\n"
   "\t\t\t\t_c = c[i]\r"
   "\n\r\n"
   "\t\t\t\tif !exclude_"
   "spaces || (_c != spa"
   "ce && _c != tab)\r\n"
   "\t\t\t\t\t_r = _r.se"
   "nd(r_op, r_val) if r"
   "_op\r\n"
   "\t\t\t\t\t_g = _g.se"
   "nd(g_op, g_val) if g"
   "_op\r\n"
   "\t\t\t\t\t_b = _b.se"
   "nd(b_op, b_val) if b"
   "_op\r\n"
   "\t\t\t\tend\r\n\r\n"
   "\t\t\t\tr_to_i = _r."
   "to_i\r\n"
   "\t\t\t\tg_to_i = _g."
   "to_i\r\n"
   "\t\t\t\tb_to_i = _b."
   "to_i\r\n\r\n"
   "\t\t\t\tclamped_r = "
   "r_to_i < 0 ? 0 : r_t"
   "o_i > 255 ? 255 : r_"
   "to_i\r\n"
   "\t\t\t\tclamped_g = "
   "g_to_i < 0 ? 0 : g_t"
   "o_i > 255 ? 255 : g_"
   "to_i\r\n"
   "\t\t\t\tclamped_b = "
   "b_to_i < 0 ? 0 : b_t"
   "o_i > 255 ? 255 : b_"
   "to_i\r\n\r\n"
   "\t\t\t\tret = \"\\e["
   "#{init};2;#{clamped_"
   "r};#{clamped_g};#{cl"
   "amped_b}m#{_c}\"\r\n"
   "\r\n"
   "\t\t\t\t# if block_g"
   "iven\r\n"
   "\t\t\t\t\t# yield re"
   "t\r\n"
   "\t\t\t\t# else\r\n"
   "\t\t\t\t\ttemp << re"
   "t\r\n"
   "\t\t\t\t# end\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\tret = if !c.em"
   "pty?\r\n"
   "\t\t\t\tchomped ? \""
   "\\e[0m\\n\".freeze :"
   " \"\\e[0m\".freeze\r"
   "\n"
   "\t\t\telsif chomped"
   "\r\n"
   "\t\t\t\t?\\n.freeze"
   "\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\ttemp << ret\r"
   "\n\r\n"
   "\t\t\tif rotate\r\n"
   "\t\t\t\tall_rgbs.rot"
   "ate!\r\n"
   "\t\t\t\tr, g, b = al"
   "l_rgbs[0]\r\n"
   "\t\t\t\tr2, g2, b2 ="
   " all_rgbs[1]\r\n"
   "\t\t\tend\r\n"
   "\t\tend\r\n\r\n"
   "\t\ttemp\r\n"
   "\tend\r\n\r\n"
   "\t##\r\n"
   "\t# = multi_gradient"
   "(*n_arg_colours, bg:"
   " false, exclude_spac"
   "es: true, bold: fals"
   "e, blink: false)    "
   "# => string or nil\r"
   "\n"
   "\t#\r\n"
   "\t# Accepts n number"
   " of colours. Example"
   ":\r\n"
   "\t#    \'Hello world"
   " this is multi_gradi"
   "ent()\'.multi_gradie"
   "nt(\'3eb\', \'55f\',"
   " \'f55\', \'fa0\')\r"
   "\n"
   "\t#\r\n"
   "\t# In this example,"
   " multi_gradient() pa"
   "ints the string with"
   " 4 colours in one li"
   "ne.\r\n"
   "\t#\r\n"
   "\t# It Splits up a s"
   "tring with the Calls"
   " String#gradient() w"
   "ith the given number"
   " of colours\r\n"
   "\t# So each call to "
   "multi_gradient() inv"
   "olves many calls to "
   "String#gradient().\r"
   "\n"
   "\t# Hence it\'s slow"
   "er than String#gradi"
   "ent()\r\n"
   "\tdef multi_gradient"
   "(*colours,\r\n"
   "\t\texclude_spaces: "
   "true,\r\n"
   "\t\tbg: false,\r\n"
   "\t\tbold: false,\r\n"
   "\t\titalic: false,\r"
   "\n"
   "\t\tunderline: false"
   ",\r\n"
   "\t\tblink: false,\r"
   "\n"
   "\t\tstrikethrough: f"
   "alse,\r\n"
   "\t\tdouble_underline"
   ": false,\r\n"
   "\t\toverline: false,"
   "\r\n"
   "\t\t&block\r\n"
   "\t\t)\r\n\r\n"
   "\t\tlen = colours.le"
   "ngth\r\n"
   "\t\traise ArgumentEr"
   "ror, \"Minimum two c"
   "olours are required,"
   " given #{len}\" if l"
   "en < 2\r\n\r\n"
   "\t\tdiv = len - 1\r"
   "\n"
   "\t\tdiv_1 = div - 1"
   "\r\n"
   "\t\tret = \'\'\r\n"
   "\t\tblock_given = bl"
   "ock_given?\r\n\r\n"
   "\t\tparams = {\r\n"
   "\t\t\texclude_spaces"
   ": exclude_spaces,\r"
   "\n"
   "\t\t\tbg: bg,\r\n"
   "\t\t\tbold: bold,\r"
   "\n"
   "\t\t\titalic: italic"
   ",\r\n"
   "\t\t\tunderline: und"
   "erline,\r\n"
   "\t\t\tblink: blink,"
   "\r\n"
   "\t\t\tstrikethrough:"
   " strikethrough,\r\n"
   "\t\t\tdouble_underli"
   "ne: double_underline"
   ",\r\n"
   "\t\t\toverline: over"
   "line,\r\n"
   "\t\t}\r\n\r\n"
   "\t\tlines { |l|\r\n"
   "\t\t\t_len = l.lengt"
   "h\r\n\r\n"
   "\t\t\tlen, c = _len."
   "/(div.to_f).round, c"
   "olours.dup\r\n"
   "\t\t\tcounter, i, j "
   "= -1, -1, 0\r\n"
   "\t\t\tch = \'\'\r\n"
   "\r\n"
   "\t\t\twhile x = l[i "
   "+= 1] do\r\n"
   "\t\t\t\tcounter += 1"
   "\r\n\r\n"
   "\t\t\t\t# colour % l"
   "en == 0 is very slow"
   " approach\r\n"
   "\t\t\t\tif counter ="
   "= len && j < div_1\r"
   "\n"
   "\t\t\t\t\tcounter, j"
   " = 0, j + 1\r\n"
   "\t\t\t\t\tret << ch."
   "gradient(c[0], c[1],"
   " **params)\r\n"
   "\t\t\t\t\tc.rotate!"
   "\r\n"
   "\t\t\t\t\tch.clear\r"
   "\n"
   "\t\t\t\tend\r\n\r\n"
   "\t\t\t\tch << x\r\n"
   "\t\t\tend\r\n\r\n"
   "\t\t\tret << ch.grad"
   "ient(c[0], c[1], **p"
   "arams)\r\n"
   "\t\t}\r\n\r\n"
   "\t\tret\r\n"
   "\tend\r\n"
   "end\r\n\r\n"
   "c = [\r\n"
   "\t0x00c0ff, 0xffff40"
   ", 0xff8359,\r\n"
   "\t0x59c2ff, 0x1270e3"
   ", 0x15eded,\r\n"
   "\t0x029cf5, 0xff7cce"
   ",\r\n"
   "\t0xf5317f, 0xb122e5"
   "\r\n"
   "]\r\n\r\n"
   "File.open(TMPFILE, "
   "\'w\').write(\'0\') "
   "rescue nil unless Fi"
   "le.exist?(TMPFILE)\r"
   "\n"
   "value = File.read(TM"
   "PFILE).to_i % c.leng"
   "th rescue nil\r\n"
   "File.open(TMPFILE, "
   "\'w\').write(value.+"
   "(1).to_s) rescue nil"
   "\r\n"
   "c.rotate!(value)\r\n"
   "\r\n"
   "print %Q(\\u256d\\u2"
   "504\\u2504[#{logname"
   "}\\u02d0\\u02d0#{hos"
   "tname}]\\u2505).mult"
   "i_gradient(c.shift, "
   "c.shift, c.shift) <<"
   "\r\n"
   "\t%Q([#{PWD}]).multi"
   "_gradient(c.shift, c"
   ".shift, c.shift, bol"
   "d: true) <<\r\n"
   "\t%Q(\\u2505[#{child"
   "ren} item#{children "
   "== 1 ? \'\' : \'s\'}"
   "]).multi_gradient(c."
   "shift, c.shift) <<\r"
   "\n"
   "\t%Q(\\u2505[#{curre"
   "nt_time}]).multi_gra"
   "dient(c.shift, c.shi"
   "ft) <<\r\n"
   "\t%Q(\\n\\u2570\\u25"
   "00\\u2500\\u257c\\u2"
   "b9a\\s)\r\n"
);}